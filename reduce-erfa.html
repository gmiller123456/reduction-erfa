<!DOCTYPE html>
<html>
<head>
	<title>Sofa</title>
</head>
<body>
<script src="sofa.src.js"></script>
<script src="ascp2000.405.js"></script>
<script src="de405.js"></script>

<script>
"use strict";

const au= 149597870.691;
const T0 = 2451545.00000000;
const ASEC360 = 1296000.0;
const ASEC2RAD = 4.848136811095359935899141e-6;
const TWOPI=Math.PI*2;
const DEG2RAD=Math.PI/180.0;
const ERAD = 6378136.6;
const F = 0.003352819697896;
const ANGVEL = 7.2921150e-5;
const AU_KM = 1.4959787069098932e+8;
const C_AUDAY = 173.1446326846693;
const AU = 1.4959787069098932e+11;
const RAD2DEG = 57.295779513082321;
const C = 299792458.0;

const year = 2008;
const month = 4;
const day = 24;
const hour = 10;
const min = 36;
const sec = 18;

const jd_utc=IAU.dtf2d("UTC",year,month,day,hour,min,sec);

const de=new DE405();

const observer={'latitude': 42.0, 'longitude': -70.0, 'height': 0.0};
getTopoCentric(jd_utc,observer,9)

function getTopoCentric(jd_utc,observer,bodyNumber){
	const jd_tai=IAU.utctai(jd_utc[1],jd_utc[2]);
	const jd_tt=IAU.taitt(jd_tai[1],jd_tai[2]);
	const jd_ut1=IAU.utcut1(jd_utc[1],jd_utc[2],-0.387845);
	//const jd_ut1=IAU.utcut1(jd_utc[1],jd_utc[2],0);

	//TODO: compute TDB
	const TDB_TT=0;
	//const jd_tdb=IAU.tttdb(jd_tt[1],jd_tt[2],TDB_TT);
	//const jd_tdb=[0,2454580.942629462,0];
	const jd_tdb=jd_tt;

	const earth=getBodyPV(2,jd_tdb[1]+jd_tdb[2]);
	const gast=IAU.gst00a(jd_ut1[1],jd_ut1[2],jd_tt[1],jd_tt[2]);
	const geopv=IAU.pvtob(observer.longitude*DEG2RAD,observer.latitude*DEG2RAD,0,0,0,0,gast); //meters, m/s

	const rnpb=IAU.pnm06a(jd_tt[1], jd_tt[2]);
	const rnpb0=IAU.tr(rnpb);
	const geop=IAU.rxp(rnpb0,geopv[0]).map(x=>x/AU);
	const geov=IAU.rxp(rnpb0,geopv[1]).map(x=>x/AU*60*60*24);

	for(let i=0;i<3;i++){
		geop[i]=earth[i]+geop[i];
		geov[i]=earth[i+3]+geov[i];
	}

	const pv1=getBodyPV(bodyNumber,jd_tdb[1]+jd_tdb[2]);

	const pos2=new Array();
	const vel2=new Array();
	for(let i=0;i<3;i++){
		pos2[i]=pv1[i]-geop[i];
		vel2[i]=pv1[i+3]-geov[i];
	}

   let lighttime = Math.sqrt (pos2[0] * pos2[0] + pos2[1] * pos2[1] + pos2[2] * pos2[2]) / C_AUDAY ;

	let pos3=getBodyPV(bodyNumber,jd_tdb[1]+jd_tdb[2]-lighttime);
	const vel3=new Array();
	for(let i=0;i<3;i++){
		pos3[i]=pos3[i]-geop[i];
		vel3[i]=pos3[i+3]-geov[i];
	}

	//TODO: gavitational deflection
	//const temp=limb_angle(pos3,geopv);
	//const frlimb=temp[1];
	//let loc=1;
	//if (frlimb < 0.8) loc = 0;

	//const pos4=grav_def (jd_tdb,loc,pos3,pvb);
	const pos4=pos3;

	const pos5=aberration (pos4,geop,geov,jd_tdb);

	const pos8=IAU.rxp(rnpb,pos5);

	const radec=vector2radec(pos8);

	console.log(radec);
}

function equ2hor ( jd_ut1,  delta_t,  xp,  yp, location,  ra,  dec, ref_option)
{
   var j;

   var sinlat, coslat, sinlon, coslon, sindc, cosdc, sinra, cosra,
      uze, une, uwe, uz, un, uw, p, pz, pn, pw,
      proj, zd0, zd1, refr, sinzd, coszd, sinzd0, coszd0, pr;

   //Return values:
   var zd, az, rar, decr;

	uze=new Array();
	une=new Array();
	uwe=new Array();
	uz=new Array();
	un=new Array();
	uw=new Array();
	p=new Array();
	pr=new Array();

/*
   Preliminaries.
*/

   rar = ra;
   decr = dec;

   sinlat = Math.sin (location.latitude * DEG2RAD);
   coslat = Math.cos (location.latitude * DEG2RAD);
   sinlon = Math.sin (location.longitude * DEG2RAD);
   coslon = Math.cos (location.longitude * DEG2RAD);
   sindc = Math.sin (dec * DEG2RAD);
   cosdc = Math.cos (dec * DEG2RAD);
   sinra = Math.sin (ra * 15.0 * DEG2RAD);
   cosra = Math.cos (ra * 15.0 * DEG2RAD);

/*
   Set up orthonormal basis vectors in local Earth-fixed system.

   Define vector toward local zenith in Earth-fixed system (z axis).
*/
   uze[0] = coslat * coslon;
   uze[1] = coslat * sinlon;
   uze[2] = sinlat;

/*
   Define vector toward local north in Earth-fixed system (x axis).
*/

   une[0] = -sinlat * coslon;
   une[1] = -sinlat * sinlon;
   une[2] = coslat;

/*
   Define vector toward local west in Earth-fixed system (y axis).
*/

   uwe[0] = sinlon;
   uwe[1] = -coslon;
   uwe[2] = 0.0;

/*
   Obtain vectors in celestial system.

   Rotate Earth-fixed orthonormal basis vectors to celestial system
   (wrt equator and equinox of date).
*/
spin (-gast * 15.0,v1, v2);

   ter2cel (jd_ut1,0.0,delta_t,1,1,xp,yp,uze, uz);
   ter2cel (jd_ut1,0.0,delta_t,1,1,xp,yp,une, un);
   ter2cel (jd_ut1,0.0,delta_t,1,1,xp,yp,uwe, uw);

/*
   Define unit vector 'p' toward object in celestial system
   (wrt equator and equinox of date).
*/

   p[0] = cosdc * cosra;
   p[1] = cosdc * sinra;
   p[2] = sindc;

/*
   Compute coordinates of object wrt orthonormal basis.

   Compute components of 'p' - projections of 'p' onto rotated
   Earth-fixed basis vectors.
*/

   pz = p[0] * uz[0] + p[1] * uz[1] + p[2] * uz[2];
   pn = p[0] * un[0] + p[1] * un[1] + p[2] * un[2];
   pw = p[0] * uw[0] + p[1] * uw[1] + p[2] * uw[2];

/*
   Compute azimuth and zenith distance.
*/

   proj = Math.sqrt (pn * pn + pw * pw);

   if (proj > 0.0)
      az = -Math.atan2 (pw, pn) * RAD2DEG;

   if (az < 0.0)
      az += 360.0;

   if (az >= 360.0)
      az -= 360.0;

   zd = Math.atan2 (proj, pz) * RAD2DEG;

/*
   Apply atmospheric refraction if requested.
*/
	//TODO: refraction

	var ret=new Array();
	ret[0]=zd;
	ret[1]=az;

	return ret;
}

function spin (angle, pos1, pos2)
{
   var xx, yx, zx, xy, yy, zy, xz, yz, zz;
   var angr, cosang, sinang;

      angr = angle * DEG2RAD;
      cosang = Math.cos (angr);
      sinang = Math.sin (angr);

/*
   Rotation matrix follows.
*/

      xx =  cosang;
      yx =  sinang;
      zx =  0.0;
      xy =  -sinang;
      yy =  cosang;
      zy =  0.0;
      xz =  0.0;
      yz =  0.0;
      zz =  1.0;


/*
   Perform rotation.
*/

   pos2[0] = xx * pos1[0] + yx * pos1[1] + zx * pos1[2];
   pos2[1] = xy * pos1[0] + yy * pos1[1] + zy * pos1[2];
   pos2[2] = xz * pos1[0] + yz * pos1[1] + zz * pos1[2];

   return;
}


function aberration(body,observerPosition,observerVelocity,jd_tdb){
	const bodyDist=Math.sqrt(body[0]*body[0]+body[1]*body[1]+body[2]*body[2]);
	const bodyUnit=body.map(x=>x/bodyDist);

	let sun=getBodyPV(10,jd_tdb[1]+jd_tdb[2]);
	for(let i=0;i<3;i++){
		sun[i]=sun[i]-observerPosition[i];
	}
	const sunDistance=Math.sqrt(sun[0]*sun[0]+sun[1]*sun[1]+sun[2]*sun[2]);
	const vel2=observerVelocity.map(x=>x/C_AUDAY);

	let vlen=Math.sqrt(observerVelocity[0]*observerVelocity[0]+observerVelocity[1]*observerVelocity[1]+observerVelocity[2]*observerVelocity[2]);
	vlen=vlen/C_AUDAY;
	const bm1=Math.sqrt(1-vlen*vlen);

	return IAU.ab(bodyUnit,vel2,sunDistance,bm1);
}

function vector2radec (pos)
{
   let xyproj;
   let ra,dec;

   xyproj = Math.sqrt (pos[0] * pos[0] + pos[1] * pos[1]);
   if ((xyproj == 0.0) && (pos[2] == 0))
   {
      ra = 0.0;
      dec = 0.0;
      return 1;
   }
    else if (xyproj == 0.0)
   {
      ra = 0.0;
      if (pos[2] < 0.0)
         dec = -90.0;
       else
         dec = 90.0;
      return 2;
   }
    else
   {
      ra = Math.atan2 (pos[1], pos[0]) / ASEC2RAD / 54000.0;
      dec = Math.atan2 (pos[2], xyproj) / ASEC2RAD / 3600.0;

      if (ra < 0.0)
         ra += 24.0;
   }

   const temp=new Array();
   temp[0]=ra;
   temp[1]=dec;
   return temp;
}

//TODO: Actually implement
function tt2tdb(tt) {
	return tt;
}


function getBodyPV(body,jd_tdb){
	let b;
	const AU_KM = 1.4959787069098932e+8;

	switch (body){
		case 2: //Earth
			b=de.getEarth(jd_tdb);
			break;
		case 9: //Moon
			const e=de.getEarth(jd_tdb);
			b=de.getAllPropertiesForSeries(body,jd_tdb);
			for(let i=0;i<e.length;i++){
				b[i]=b[i]+e[i];
			}
			break;
		default:
			b=de.getAllPropertiesForSeries(body,jd_tdb);
			break;
	}
	for(let i=0;i<b.length;i++){
		b[i]=b[i]/AU_KM;
	}
	return b;

}


</script>


</body>
</html>